@inherits Fluxor.Blazor.Web.Components.FluxorComponent
@implements IDisposable

<MudCard Class="rounded my-3 mx-3" Elevation="3" Outlined="true">
    <CardHeaderSwitch HeaderText="@($"Instrument {Instrument}")"
                      ConfigurationStatus="@Status"
                      ValueChanged="HandleIsEnabledChange"/>
    <MudCardContent>
        <MudGrid Justify="Justify.SpaceBetween">
            <MudItem xs="12" sm="6" md="5" lg="4" xl="3" xxl="2">
                <AutocompleteWithPopover T="GeneralMidi2Program"
                                         SearchFunc="MidiInstrumentSearchFunc"
                                         ToStringFunc="@(instrument => instrument.ToSpaceSeparatedString())"
                                         ValueProvider="() => MidiInstrument"
                                         ValueChanged="HandleMidiInstrumentChange"
                                         AnchorOrigin="InstrumentFilterAnchorOrigin"
                                         TransformOrigin="InstrumentFilterTransformOrigin"
                                         Icon="@Icons.Material.TwoTone.FilterAlt"
                                         Label="Instrument"
                                         IsDisabled="Status.IsFrozen()">
                    <PopoverContent>
                        <MudText Align="Align.Center" Class="mt-n3" Typo="Typo.h6">Filter Instruments</MudText>
                        <MudPaper Class="d-flex flex-column overflow-x-auto mt-1 ml-n4 mr-n4 mb-n4" Outlined="true" Height="33vh">
                            @foreach (var filter in MidiInstrumentFilters)
                            {
                                <MudCheckBox T="bool" Label="@filter.Type.ToSpaceSeparatedString()" Color="Color.Tertiary" UncheckedColor="Color.Secondary" Dense="true" Value="@filter.IsEnabled" ValueChanged="val => { filter.IsEnabled = val; HandleInstrumentFilterChange(); }"/>
                            }
                        </MudPaper>
                    </PopoverContent>
                </AutocompleteWithPopover>
            </MudItem>
            <MudFlexBreak/>
            <MudItem Class="d-none d-sm-flex mb-n8 mt-n8" xs="12" sm="12">
                <RangeSlider T="int"
                             @bind-Value="LowestPitchNoteIndex"
                             @bind-UpperValue="HighestPitchNoteIndex"
                             Size="Size.Medium"
                             Variant="Variant.Filled"
                             Color="Color.Tertiary"
                             ValueLabel="true"
                             Range="true"
                             TickMarks="true"
                             Immediate="true"
                             Min="SliderMin"
                             Max="SliderMax"
                             MinSlideableMax="MinSlideableMax"
                             MaxSlideableMin="MaxSlideableMin"
                             Step="1"
                             MinDistance="CompositionConfiguration.MinInstrumentRange"
                             LabelText="@LowestPitchNote.ToString()"
                             UpperLabelText="@HighestPitchNote.ToString()"
                             Disabled="Status.IsFrozen()" />
            </MudItem>
            <MudItem xs="12" sm="4" md="3" lg="2" xl="2" xxl="2">
                <MudSelect T="int"
                           @bind-Value="LowestPitchNoteIndex"
                           Label="Lowest Pitch"
                           Variant="Variant.Outlined"
                           AdornmentIcon="@Icons.Material.Outlined.ArrowCircleDown"
                           Adornment="Adornment.End"
                           AdornmentColor="Color.Secondary"
                           Disabled="Status.IsFrozen()">
                    @foreach (var noteIndex in LowestPitchNoteIndices)
                    {
                        <MudSelectItem Value="noteIndex">@CompositionConfigurationState.Value.Notes[noteIndex]</MudSelectItem>
                    }
                </MudSelect>
            </MudItem>
            <MudItem xs="12" sm="4" md="3" lg="2" xl="2" xxl="2">
                <MudSelect @bind-Value="HighestPitchNoteIndex"
                           Label="Highest Pitch"
                           T="int"
                           Variant="Variant.Outlined"
                           AdornmentIcon="@Icons.Material.Outlined.ArrowCircleUp"
                           Adornment="Adornment.End"
                           AdornmentColor="Color.Secondary"
                           Disabled="Status.IsFrozen()">
                    @foreach (var noteIndex in HighestPitchNoteIndices)
                    {
                        <MudSelectItem Value="noteIndex">@CompositionConfigurationState.Value.Notes[noteIndex]</MudSelectItem>
                    }
                </MudSelect>
            </MudItem>
        </MudGrid>
    </MudCardContent>
</MudCard>

@code
{
    [Parameter, EditorRequired] public required Instrument Instrument { get; set; }

    private Note LowestPitchNote => InstrumentConfigurationState.Value[Instrument]?.MinNote ?? Notes.C3;

    private Note HighestPitchNote => InstrumentConfigurationState.Value[Instrument]?.MaxNote ?? Notes.C6;

    private GeneralMidi2Program MidiInstrument => InstrumentConfigurationState.Value[Instrument]?.MidiProgram ?? GeneralMidi2Program.AcousticGrandPiano;

    private ConfigurationStatus Status => InstrumentConfigurationState.Value[Instrument]?.Status ?? ConfigurationStatus.Disabled;

    private const int SliderMin = 0;

    private int SliderMax => CompositionConfigurationState.Value.Notes.Count - 1;

    private int MinSlideableMax => SliderMax - CompositionConfiguration.MinInstrumentRange;

    private int MaxSlideableMin => SliderMin + CompositionConfiguration.MinInstrumentRange;

    private int _lowestPitchNoteIndex;

    private int LowestPitchNoteIndex
    {
        get => _lowestPitchNoteIndex;
        set
        {
            if (value == _lowestPitchNoteIndex)
            {
                return;
            }

            _lowestPitchNoteIndex = value;
            HandleLowestPitchNoteIndexChange(_lowestPitchNoteIndex);

            HighestPitchNoteIndex = (HighestPitchNoteIndex - _lowestPitchNoteIndex) switch
            {
                > CompositionConfiguration.MaxInstrumentRange => _lowestPitchNoteIndex + CompositionConfiguration.MaxInstrumentRange,
                < CompositionConfiguration.MinInstrumentRange => Math.Min(_lowestPitchNoteIndex + CompositionConfiguration.MinInstrumentRange, SliderMax),
                _ => HighestPitchNoteIndex
            };
        }
    }

    private int _highestPitchNoteIndex;

    private int HighestPitchNoteIndex
    {
        get => _highestPitchNoteIndex;
        set
        {
            if (value == _highestPitchNoteIndex)
            {
                return;
            }

            _highestPitchNoteIndex = value;
            HandleHighestPitchIndexChange(_highestPitchNoteIndex);

            LowestPitchNoteIndex = (_highestPitchNoteIndex - LowestPitchNoteIndex) switch
            {
                > CompositionConfiguration.MaxInstrumentRange => _highestPitchNoteIndex - CompositionConfiguration.MaxInstrumentRange,
                < CompositionConfiguration.MinInstrumentRange => Math.Max(_highestPitchNoteIndex - CompositionConfiguration.MinInstrumentRange, SliderMin),
                _ => LowestPitchNoteIndex
            };
        }
    }

    private sealed class MidiInstrumentFilter
    {
        public MidiInstrumentType Type { get; init; }

        public bool IsEnabled { get; set; }
    };

    private IEnumerable<MidiInstrumentFilter> MidiInstrumentFilters = [];

    private IEnumerable<int> NoteIndices => Enumerable.Range(SliderMin, SliderMax + 1);

    private IEnumerable<int> LowestPitchNoteIndices => NoteIndices.Take(CompositionConfigurationState.Value.Notes.Count - CompositionConfiguration.MinInstrumentRange);

    private IEnumerable<int> HighestPitchNoteIndices => NoteIndices.Skip(CompositionConfiguration.MinInstrumentRange);

    private IDisposable? InstrumentConfigurationStateSubscription;

    private FrozenDictionary<string, GeneralMidi2Program> MidiInstruments = FrozenDictionary<string, GeneralMidi2Program>.Empty;

    private Origin InstrumentFilterAnchorOrigin = Origin.TopRight;

    private Origin InstrumentFilterTransformOrigin = Origin.TopLeft;

    protected override void OnInitialized()
    {
        base.OnInitialized();

        _lowestPitchNoteIndex = CompositionConfigurationState.Value.Notes.IndexOf(LowestPitchNote);
        _highestPitchNoteIndex = CompositionConfigurationState.Value.Notes.IndexOf(HighestPitchNote);

        if (PhysicalDeviceInfo.IsMobile)
        {
            InstrumentFilterAnchorOrigin = Origin.TopRight;
            InstrumentFilterTransformOrigin = Origin.TopRight;
        }

        foreach (var midiInstrumentType in EnumUtils<MidiInstrumentType>.AsEnumerable().Where(midiInstrumentType => midiInstrumentType != MidiInstrumentType.All && midiInstrumentType != MidiInstrumentType.None))
        {
            MidiInstrumentFilters = MidiInstrumentFilters.Append(new MidiInstrumentFilter
            {
                Type = midiInstrumentType,
                IsEnabled = true
            });
        }

        MidiInstruments = MidiInstrumentRepository.GetAllMidiInstruments().ToFrozenDictionary(
            instrument => instrument.ToSpaceSeparatedString(),
            instrument => instrument
        );

        InstrumentConfigurationStateSubscription = InstrumentConfigurationState
            .ObserveChanges()
            .Subscribe(_ =>
            {
                var configuration = InstrumentConfigurationState.Value[Instrument]!;

                _lowestPitchNoteIndex = CompositionConfigurationState.Value.Notes.IndexOf(configuration.MinNote);
                _highestPitchNoteIndex = CompositionConfigurationState.Value.Notes.IndexOf(configuration.MaxNote);
            });
    }

    private void HandleIsEnabledChange(ConfigurationStatus status) => Dispatcher.Dispatch(new UpdateInstrumentConfiguration(Instrument, LowestPitchNote, HighestPitchNote, MidiInstrument, status, IsUserApplied: true));

    private void HandleLowestPitchNoteIndexChange(int noteIndex) => Dispatcher.Dispatch(
        new UpdateInstrumentConfiguration(
            Instrument,
            CompositionConfigurationState.Value.Notes[noteIndex],
            HighestPitchNote,
            MidiInstrument,
            Status,
            IsUserApplied: true
        )
    );

    private void HandleHighestPitchIndexChange(int noteIndex) => Dispatcher.Dispatch(
        new UpdateInstrumentConfiguration(
            Instrument,
            LowestPitchNote,
            CompositionConfigurationState.Value.Notes[noteIndex],
            MidiInstrument,
            Status,
            IsUserApplied: true
        )
    );

    private void HandleMidiInstrumentChange(GeneralMidi2Program instrument) => Dispatcher.Dispatch(new UpdateInstrumentConfiguration(Instrument, LowestPitchNote, HighestPitchNote, instrument, Status, IsUserApplied: true));

    private void HandleInstrumentFilterChange()
    {
        if (!MidiInstrumentFilters.Any(filter => filter.IsEnabled))
        {
            MidiInstruments = MidiInstrumentRepository.GetAllMidiInstruments().ToFrozenDictionary(
                instrument => instrument.ToSpaceSeparatedString(),
                instrument => instrument
            );

            return;
        }

        var includedMidiInstruments = MidiInstrumentFilters.Where(filter => filter.IsEnabled).Aggregate(MidiInstrumentType.None, (current, filter) => current | filter.Type);
        var midiInstruments = MidiInstrumentRepository.GetMidiInstruments(includedMidiInstruments).ToList();

        MidiInstruments = midiInstruments.ToFrozenDictionary(
            instrument => instrument.ToSpaceSeparatedString(),
            instrument => instrument
        );

        if (MidiInstruments.ContainsKey(MidiInstrument.ToSpaceSeparatedString()))
        {
            return;
        }

        Dispatcher.Dispatch(new UpdateInstrumentConfiguration(
            Instrument,
            LowestPitchNote,
            HighestPitchNote,
            MidiInstruments.Values.Order().First(),
            Status,
            IsUserApplied: true
        ));
    }

    private async Task<IEnumerable<GeneralMidi2Program>> MidiInstrumentSearchFunc(string search, CancellationToken cancellationToken)
    {
        var midiInstruments = string.IsNullOrWhiteSpace(search)
            ? MidiInstruments.Values
            : MidiInstruments.Keys
                .Where(key => key.Contains(search, StringComparison.OrdinalIgnoreCase))
                .Select(key => MidiInstruments[key]);

        return await Task.FromResult(midiInstruments.OrderBy(instrument => instrument.ToSpaceSeparatedString(), StringComparer.OrdinalIgnoreCase));
    }

    protected virtual void Dispose(bool disposing)
    {
        if (disposing)
        {
            InstrumentConfigurationStateSubscription?.Dispose();
        }
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
}
