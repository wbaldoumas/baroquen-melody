@inherits Fluxor.Blazor.Web.Components.FluxorComponent
@implements IDisposable

<MudCard Class="rounded my-3 mx-3" Elevation="3" Outlined="true">
    <CardHeaderSwitch HeaderText="@($"Instrument {Instrument}")"
                      IsEnabled="@IsEnabled"
                      ValueChanged="HandleIsEnabledChange"/>
    <MudCardContent>
        <MudGrid Justify="Justify.SpaceBetween">
            <MudItem xs="12" sm="6" md="5" lg="4" xl="3" xxl="2">
                <AutocompleteWithPopover T="GeneralMidi2Program"
                                         SearchFunc="InstrumentSearchFunc"
                                         ToStringFunc="ToStringFunc"
                                         ValueProvider="() => MidiInstrument"
                                         ValueChanged="HandleMidiInstrumentChange"
                                         Label="Instrument">
                    <PopoverContent>
                        <MudText>The <MudLink Color="Color.Tertiary" Href="https://en.wikipedia.org/wiki/MIDI">MIDI instrument</MudLink> to use in the composition.</MudText>
                    </PopoverContent>
                </AutocompleteWithPopover>
            </MudItem>
            <MudFlexBreak/>
            <MudItem Class="d-none d-sm-flex mb-n8 mt-n8" xs="12" sm="12">
                <RangeSlider T="int"
                             @bind-Value="LowestPitchNoteIndex"
                             @bind-UpperValue="HighestPitchNoteIndex"
                             Size="Size.Medium"
                             Variant="Variant.Filled"
                             Color="Color.Tertiary"
                             ValueLabel="true"
                             Range="true"
                             TickMarks="true"
                             Immediate="true"
                             Min="SliderMin"
                             Max="SliderMax"
                             MinSlideableMax="MinSlideableMax"
                             MaxSlideableMin="MaxSlideableMin"
                             Step="1"
                             MinDistance="CompositionConfiguration.MinInstrumentRange"
                             LabelText="@LowestPitchNote.ToString()"
                             UpperLabelText="@HighestPitchNote.ToString()"/>
            </MudItem>
            <MudItem xs="12" sm="4" md="3" lg="2" xl="2" xxl="2">
                <MudSelect T="int"
                           @bind-Value="LowestPitchNoteIndex"
                           Label="Lowest Pitch"
                           Variant="Variant.Outlined"
                           AdornmentIcon="@Icons.Material.Outlined.ArrowCircleDown"
                           Adornment="Adornment.End"
                           AdornmentColor="Color.Secondary">
                    @foreach (var noteIndex in LowestPitchNoteIndices)
                    {
                        <MudSelectItem Value="noteIndex">@CompositionConfigurationState.Value.Notes[noteIndex]</MudSelectItem>
                    }
                </MudSelect>
            </MudItem>
            <MudItem xs="12" sm="4" md="3" lg="2" xl="2" xxl="2">
                <MudSelect @bind-Value="HighestPitchNoteIndex"
                           Label="Highest Pitch"
                           T="int"
                           Variant="Variant.Outlined"
                           AdornmentIcon="@Icons.Material.Outlined.ArrowCircleUp"
                           Adornment="Adornment.End"
                           AdornmentColor="Color.Secondary">
                    @foreach (var noteIndex in HighestPitchNoteIndices)
                    {
                        <MudSelectItem Value="noteIndex">@CompositionConfigurationState.Value.Notes[noteIndex]</MudSelectItem>
                    }
                </MudSelect>
            </MudItem>
        </MudGrid>
    </MudCardContent>
</MudCard>

@code
{
    [Parameter, EditorRequired] public required Instrument Instrument { get; set; }

    private Note LowestPitchNote => InstrumentConfigurationState.Value[Instrument]?.MinNote ?? Notes.C3;

    private Note HighestPitchNote => InstrumentConfigurationState.Value[Instrument]?.MaxNote ?? Notes.C6;

    private GeneralMidi2Program MidiInstrument => InstrumentConfigurationState.Value[Instrument]?.MidiProgram ?? GeneralMidi2Program.AcousticGrandPiano;

    private bool IsEnabled => InstrumentConfigurationState.Value[Instrument]?.IsEnabled ?? false;

    private const int SliderMin = 0;

    private int SliderMax => CompositionConfigurationState.Value.Notes.Count - 1;

    private int MinSlideableMax => SliderMax - CompositionConfiguration.MinInstrumentRange;

    private int MaxSlideableMin => SliderMin + CompositionConfiguration.MinInstrumentRange;

    private int _lowestPitchNoteIndex;

    private int LowestPitchNoteIndex
    {
        get => _lowestPitchNoteIndex;
        set
        {
            if (value == _lowestPitchNoteIndex)
            {
                return;
            }

            _lowestPitchNoteIndex = value;
            HandleLowestPitchNoteIndexChange(_lowestPitchNoteIndex);

            HighestPitchNoteIndex = (HighestPitchNoteIndex - _lowestPitchNoteIndex) switch
            {
                > CompositionConfiguration.MaxInstrumentRange => _lowestPitchNoteIndex + CompositionConfiguration.MaxInstrumentRange,
                < CompositionConfiguration.MinInstrumentRange => Math.Min(_lowestPitchNoteIndex + CompositionConfiguration.MinInstrumentRange, SliderMax),
                _ => HighestPitchNoteIndex
            };
        }
    }

    private int _highestPitchNoteIndex;

    private int HighestPitchNoteIndex
    {
        get => _highestPitchNoteIndex;
        set
        {
            if (value == _highestPitchNoteIndex)
            {
                return;
            }

            _highestPitchNoteIndex = value;
            HandleHighestPitchIndexChange(_highestPitchNoteIndex);

            LowestPitchNoteIndex = (_highestPitchNoteIndex - LowestPitchNoteIndex) switch
            {
                > CompositionConfiguration.MaxInstrumentRange => _highestPitchNoteIndex - CompositionConfiguration.MaxInstrumentRange,
                < CompositionConfiguration.MinInstrumentRange => Math.Max(_highestPitchNoteIndex - CompositionConfiguration.MinInstrumentRange, SliderMin),
                _ => LowestPitchNoteIndex
            };
        }
    }

    private IEnumerable<int> NoteIndices => Enumerable.Range(SliderMin, SliderMax + 1);

    private IEnumerable<int> LowestPitchNoteIndices => NoteIndices.Take(CompositionConfigurationState.Value.Notes.Count - CompositionConfiguration.MinInstrumentRange);

    private IEnumerable<int> HighestPitchNoteIndices => NoteIndices.Skip(CompositionConfiguration.MinInstrumentRange);

    private IDisposable? InstrumentConfigurationStateSubscription;

    private Dictionary<string, GeneralMidi2Program> MidiInstruments = EnumUtils<GeneralMidi2Program>
        .AsEnumerable()
        .ToDictionary(
            instrument => instrument.ToSpaceSeparatedString(),
            instrument => instrument
        );

    protected override void OnInitialized()
    {
        base.OnInitialized();

        _lowestPitchNoteIndex = CompositionConfigurationState.Value.Notes.IndexOf(LowestPitchNote);
        _highestPitchNoteIndex = CompositionConfigurationState.Value.Notes.IndexOf(HighestPitchNote);

        InstrumentConfigurationStateSubscription = InstrumentConfigurationState
            .ObserveChanges()
            .Subscribe(_ =>
            {
                var configuration = InstrumentConfigurationState.Value[Instrument]!;

                _lowestPitchNoteIndex = CompositionConfigurationState.Value.Notes.IndexOf(configuration.MinNote);
                _highestPitchNoteIndex = CompositionConfigurationState.Value.Notes.IndexOf(configuration.MaxNote);
            });
    }

    private void HandleLowestPitchNoteIndexChange(int noteIndex) => Dispatcher.Dispatch(
        new UpdateInstrumentConfiguration(
            Instrument,
            CompositionConfigurationState.Value.Notes[noteIndex],
            HighestPitchNote,
            MidiInstrument,
            IsEnabled,
            IsUserApplied: true
        )
    );

    private void HandleHighestPitchIndexChange(int noteIndex) => Dispatcher.Dispatch(
        new UpdateInstrumentConfiguration(
            Instrument,
            LowestPitchNote,
            CompositionConfigurationState.Value.Notes[noteIndex],
            MidiInstrument,
            IsEnabled,
            IsUserApplied: true
        )
    );

    private void HandleMidiInstrumentChange(GeneralMidi2Program instrument) => Dispatcher.Dispatch(new UpdateInstrumentConfiguration(Instrument, LowestPitchNote, HighestPitchNote, instrument, IsEnabled, IsUserApplied: true));

    private void HandleIsEnabledChange(bool isEnabled) => Dispatcher.Dispatch(new UpdateInstrumentConfiguration(Instrument, LowestPitchNote, HighestPitchNote, MidiInstrument, isEnabled, IsUserApplied: true));

    private async Task<IEnumerable<GeneralMidi2Program>> InstrumentSearchFunc(string search, CancellationToken cancellationToken)
    {
        var instruments = string.IsNullOrWhiteSpace(search)
            ? MidiInstruments.Values
            : MidiInstruments.Keys
                .Where(key => key.Contains(search, StringComparison.OrdinalIgnoreCase))
                .Select(key => MidiInstruments[key]);

        return await Task.FromResult(instruments);
    }

    private static string ToStringFunc(GeneralMidi2Program instrument) => instrument.ToSpaceSeparatedString();

    protected virtual void Dispose(bool disposing)
    {
        if (disposing)
        {
            InstrumentConfigurationStateSubscription?.Dispose();
        }
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
}
