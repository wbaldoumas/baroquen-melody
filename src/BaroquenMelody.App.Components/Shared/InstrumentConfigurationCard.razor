@inherits Fluxor.Blazor.Web.Components.FluxorComponent
@implements IDisposable

<MudCard Class="rounded my-2 mx-2 mud-elevation-4" Elevation="ThemeProvider.Elevation" Outlined="true">
    <CardHeaderSwitch ConfigurationStatus="@Status"
                      ValueChanged="HandleIsEnabledChange">
        <HeaderContent>
            <MudText Typo="Typo.h6">@($"Instrument {Instrument}")</MudText>
        </HeaderContent>
    </CardHeaderSwitch>
    <MudCardContent>
        <MudGrid Justify="Justify.SpaceBetween">
            <MudItem xs="12" sm="6" md="5" lg="4" xl="3" xxl="2">
                <AutocompleteWithPopover T="GeneralMidi2Program"
                                         SearchFunc="MidiInstrumentSearchFunc"
                                         ToStringFunc="@(instrument => instrument.ToSpaceSeparatedString())"
                                         ValueProvider="() => MidiInstrument"
                                         ValueChanged="HandleMidiInstrumentChange"
                                         AnchorOrigin="InstrumentFilterAnchorOrigin"
                                         TransformOrigin="InstrumentFilterTransformOrigin"
                                         Icon="@Icons.Material.TwoTone.FilterAlt"
                                         Label="Instrument"
                                         IsDisabled="Status.IsFrozen()">
                    <PopoverContent>
                        <MudText Align="Align.Center" Class="mt-n3" Typo="Typo.h6">Filter Instruments</MudText>
                        <MudPaper Class="d-flex flex-column overflow-x-auto mt-1 ml-n4 mr-n4 mb-n4" Outlined="true" Height="33vh">
                            @foreach (var filter in MidiInstrumentFilters)
                            {
                                <MudCheckBox T="bool" Label="@filter.Type.ToSpaceSeparatedString()" Color="Color.Tertiary" UncheckedColor="Color.Secondary" Dense="true" Value="@filter.IsEnabled" ValueChanged="val => { filter.IsEnabled = val; HandleInstrumentFilterChange(); }"/>
                            }
                        </MudPaper>
                    </PopoverContent>
                </AutocompleteWithPopover>
            </MudItem>
            <MudFlexBreak/>
            <MudItem xs="12" Class="d-none d-sm-flex justify-center">
                <MudText Typo="Typo.button">Tonal Range</MudText>
            </MudItem>
            <MudItem Class="d-none d-sm-flex mb-n8 mt-n8" xs="12" sm="12">
                <RangeSlider T="int"
                             @bind-Value="LowestPitchNoteIndex"
                             @bind-UpperValue="HighestPitchNoteIndex"
                             Size="Size.Medium"
                             Variant="Variant.Filled"
                             Color="@(!Status.IsEnabled() ? Color.Dark : Color.Tertiary)"
                             ValueLabel="true"
                             Range="true"
                             TickMarks="true"
                             Immediate="true"
                             Min="TonalRangeSliderMin"
                             Max="TonalRangeSliderMax"
                             MinSlideableMax="TonalRangeMinSlideableMax"
                             MaxSlideableMin="TonalRangeMaxSlideableMin"
                             Step="1"
                             MinDistance="CompositionConfiguration.MinInstrumentRange"
                             LabelText="@LowestPitchNote.ToString()"
                             UpperLabelText="@HighestPitchNote.ToString()"
                             Disabled="Status.IsFrozen()"/>
            </MudItem>
            <MudItem xs="12" sm="4" md="3" lg="2" xl="2" xxl="2">
                <MudSelect T="int"
                           @bind-Value="LowestPitchNoteIndex"
                           Label="Lowest Pitch"
                           Variant="Variant.Outlined"
                           AdornmentIcon="@Icons.Material.Outlined.ArrowCircleDown"
                           Adornment="Adornment.End"
                           AdornmentColor="Color.Secondary"
                           Disabled="Status.IsFrozen()">
                    @foreach (var noteIndex in LowestPitchNoteIndices)
                    {
                        <MudSelectItem Value="noteIndex">@CompositionConfigurationState.Value.AvailableNotes[noteIndex]</MudSelectItem>
                    }
                </MudSelect>
            </MudItem>
            <MudItem xs="12" sm="4" md="3" lg="2" xl="2" xxl="2">
                <MudSelect @bind-Value="HighestPitchNoteIndex"
                           Label="Highest Pitch"
                           T="int"
                           Variant="Variant.Outlined"
                           AdornmentIcon="@Icons.Material.Outlined.ArrowCircleUp"
                           Adornment="Adornment.End"
                           AdornmentColor="Color.Secondary"
                           Disabled="Status.IsFrozen()">
                    @foreach (var noteIndex in HighestPitchNoteIndices)
                    {
                        <MudSelectItem Value="noteIndex">@CompositionConfigurationState.Value.AvailableNotes[noteIndex]</MudSelectItem>
                    }
                </MudSelect>
            </MudItem>
            <MudItem xs="12" Class="d-none d-sm-flex justify-center">
                <MudText Typo="Typo.button">Volume Range</MudText>
            </MudItem>
            <MudItem Class="d-none d-sm-flex mb-n8 mt-n8" xs="12" sm="12">
                <RangeSlider T="byte"
                             @bind-Value="MinVelocityValue"
                             @bind-UpperValue="MaxVelocityValue"
                             Size="Size.Medium"
                             Variant="Variant.Filled"
                             Color="@(!Status.IsEnabled() ? Color.Dark : Color.Tertiary)"
                             ValueLabel="true"
                             Range="true"
                             TickMarks="true"
                             Immediate="true"
                             MinDistance="0"
                             Min="VelocityRangeSliderMin"
                             Max="VelocityRangeSliderMax"
                             Step="1"
                             LabelText="@($"{MinVelocityValue}%")"
                             UpperLabelText="@($"{MaxVelocityValue}%")"
                             Disabled="Status.IsFrozen()"/>
            </MudItem>
            <MudItem xs="12" sm="4" md="3" lg="2" xl="2" xxl="2">
                <MudSelect T="byte"
                           @bind-Value="MinVelocityValue"
                           Label="Lowest Volume"
                           Variant="Variant.Outlined"
                           AdornmentIcon="@MinVelocityIcon"
                           Adornment="Adornment.End"
                           AdornmentColor="Color.Secondary"
                           Disabled="Status.IsFrozen()">
                    @foreach (var value in VolumeRange)
                    {
                        <MudSelectItem Value="value">@($"{value}%")</MudSelectItem>
                    }
                </MudSelect>
            </MudItem>
            <MudItem xs="12" sm="4" md="3" lg="2" xl="2" xxl="2">
                <MudSelect T="byte"
                           @bind-Value="MaxVelocityValue"
                           Label="Highest Volume"
                           Variant="Variant.Outlined"
                           AdornmentIcon="@MaxVelocityIcon"
                           Adornment="Adornment.End"
                           AdornmentColor="Color.Secondary"
                           Disabled="Status.IsFrozen()">
                    @foreach (var value in VolumeRange)
                    {
                        <MudSelectItem Value="value">@($"{value}%")</MudSelectItem>
                    }
                </MudSelect>
            </MudItem>
        </MudGrid>
    </MudCardContent>
</MudCard>

@code
{
    [Parameter, EditorRequired] public required Instrument Instrument { get; set; }

    private Note LowestPitchNote => InstrumentConfigurationState.Value[Instrument]?.MinNote ?? Notes.C3;

    private Note HighestPitchNote => InstrumentConfigurationState.Value[Instrument]?.MaxNote ?? Notes.C6;

    private GeneralMidi2Program MidiInstrument => InstrumentConfigurationState.Value[Instrument]?.MidiProgram ?? GeneralMidi2Program.AcousticGrandPiano;

    private ConfigurationStatus Status => InstrumentConfigurationState.Value[Instrument]?.Status ?? ConfigurationStatus.Disabled;

    private SevenBitNumber MinVelocity => InstrumentConfigurationState.Value[Instrument]?.MinVelocity ?? new SevenBitNumber(0);

    private SevenBitNumber MaxVelocity => InstrumentConfigurationState.Value[Instrument]?.MaxVelocity ?? new SevenBitNumber(100);

    private const byte VelocityRangeSliderMin = 0;

    private const byte VelocityRangeSliderMax = 100;

    private static IEnumerable<byte> VolumeRange => Enumerable.Range(0, 101).Select(value => (byte)value);

    private byte _minVelocityValue = 0;

    private byte MinVelocityValue
    {
        get => _minVelocityValue;
        set
        {
            if (value == _minVelocityValue)
            {
                return;
            }

            _minVelocityValue = value;
            HandleMinVelocityChange(_minVelocityValue);

            if (_minVelocityValue > _maxVelocityValue)
            {
                MaxVelocityValue = _minVelocityValue;
            }
        }
    }

    private byte _maxVelocityValue = 100;

    private byte MaxVelocityValue
    {
        get => _maxVelocityValue;
        set
        {
            if (value == _maxVelocityValue)
            {
                return;
            }

            _maxVelocityValue = value;
            HandleMaxVelocityChange(_maxVelocityValue);

            if (_maxVelocityValue < _minVelocityValue)
            {
                MinVelocityValue = _maxVelocityValue;
            }
        }
    }

    private string MinVelocityIcon => GetVelocityIcon(MinVelocityValue);

    private string MaxVelocityIcon => GetVelocityIcon(MaxVelocityValue);

    private string GetVelocityIcon(byte velocity) => velocity switch
    {
        0 => Icons.Material.Outlined.VolumeOff,
        < 50 => Icons.Material.Outlined.VolumeDown,
        _ => Icons.Material.Outlined.VolumeUp
    };

    private const int TonalRangeSliderMin = 0;

    private int TonalRangeSliderMax => CompositionConfigurationState.Value.AvailableNotes.Count - 1;

    private int TonalRangeMinSlideableMax => TonalRangeSliderMax - CompositionConfiguration.MinInstrumentRange;

    private int TonalRangeMaxSlideableMin => TonalRangeSliderMin + CompositionConfiguration.MinInstrumentRange;

    private int _lowestPitchNoteIndex;

    private int LowestPitchNoteIndex
    {
        get => _lowestPitchNoteIndex;
        set
        {
            if (value == _lowestPitchNoteIndex)
            {
                return;
            }

            _lowestPitchNoteIndex = value;
            HandleLowestPitchNoteIndexChange(_lowestPitchNoteIndex);

            HighestPitchNoteIndex = (HighestPitchNoteIndex - _lowestPitchNoteIndex) switch
            {
                > CompositionConfiguration.MaxInstrumentRange => _lowestPitchNoteIndex + CompositionConfiguration.MaxInstrumentRange,
                < CompositionConfiguration.MinInstrumentRange => Math.Min(_lowestPitchNoteIndex + CompositionConfiguration.MinInstrumentRange, TonalRangeSliderMax),
                _ => HighestPitchNoteIndex
            };
        }
    }

    private int _highestPitchNoteIndex;

    private int HighestPitchNoteIndex
    {
        get => _highestPitchNoteIndex;
        set
        {
            if (value == _highestPitchNoteIndex)
            {
                return;
            }

            _highestPitchNoteIndex = value;
            HandleHighestPitchIndexChange(_highestPitchNoteIndex);

            LowestPitchNoteIndex = (_highestPitchNoteIndex - LowestPitchNoteIndex) switch
            {
                > CompositionConfiguration.MaxInstrumentRange => _highestPitchNoteIndex - CompositionConfiguration.MaxInstrumentRange,
                < CompositionConfiguration.MinInstrumentRange => Math.Max(_highestPitchNoteIndex - CompositionConfiguration.MinInstrumentRange, TonalRangeSliderMin),
                _ => LowestPitchNoteIndex
            };
        }
    }

    private sealed class MidiInstrumentFilter
    {
        public MidiInstrumentType Type { get; init; }

        public bool IsEnabled { get; set; }
    }

    private IEnumerable<MidiInstrumentFilter> MidiInstrumentFilters = [];

    private IEnumerable<int> NoteIndices => Enumerable.Range(TonalRangeSliderMin, TonalRangeSliderMax + 1);

    private IEnumerable<int> LowestPitchNoteIndices => NoteIndices.Take(CompositionConfigurationState.Value.AvailableNotes.Count - CompositionConfiguration.MinInstrumentRange);

    private IEnumerable<int> HighestPitchNoteIndices => NoteIndices.Skip(CompositionConfiguration.MinInstrumentRange);

    private IDisposable? InstrumentConfigurationStateSubscription;

    private FrozenDictionary<string, GeneralMidi2Program> MidiInstruments = FrozenDictionary<string, GeneralMidi2Program>.Empty;

    private Origin InstrumentFilterAnchorOrigin = Origin.TopRight;

    private Origin InstrumentFilterTransformOrigin = Origin.TopLeft;

    protected override void OnInitialized()
    {
        base.OnInitialized();

        _minVelocityValue = MinVelocity;
        _maxVelocityValue = MaxVelocity;

        _lowestPitchNoteIndex = CompositionConfigurationState.Value.AvailableNotes.IndexOf(LowestPitchNote);
        _highestPitchNoteIndex = CompositionConfigurationState.Value.AvailableNotes.IndexOf(HighestPitchNote);

        if (PhysicalDeviceInfo.IsMobile)
        {
            InstrumentFilterAnchorOrigin = Origin.TopRight;
            InstrumentFilterTransformOrigin = Origin.TopRight;
        }

        foreach (var midiInstrumentType in EnumUtils<MidiInstrumentType>.AsEnumerable().Where(midiInstrumentType => midiInstrumentType != MidiInstrumentType.All && midiInstrumentType != MidiInstrumentType.None))
        {
            MidiInstrumentFilters = MidiInstrumentFilters.Append(new MidiInstrumentFilter
            {
                Type = midiInstrumentType,
                IsEnabled = true
            });
        }

        MidiInstruments = MidiInstrumentRepository.GetAllMidiInstruments().ToFrozenDictionary(
            instrument => instrument.ToSpaceSeparatedString(),
            instrument => instrument
        );

        InstrumentConfigurationStateSubscription = InstrumentConfigurationState
            .ObserveChanges()
            .Subscribe(_ =>
            {
                var configuration = InstrumentConfigurationState.Value[Instrument]!;

                _minVelocityValue = configuration.MinVelocity;
                _maxVelocityValue = configuration.MaxVelocity;

                _lowestPitchNoteIndex = CompositionConfigurationState.Value.AvailableNotes.IndexOf(configuration.MinNote);
                _highestPitchNoteIndex = CompositionConfigurationState.Value.AvailableNotes.IndexOf(configuration.MaxNote);
            });
    }

    private void HandleIsEnabledChange(ConfigurationStatus status) => Dispatcher.Dispatch(
        new UpdateInstrumentConfiguration(
            Instrument,
            LowestPitchNote,
            HighestPitchNote,
            MinVelocity,
            MaxVelocity,
            MidiInstrument,
            status,
            IsUserApplied: true
        )
    );

    private void HandleLowestPitchNoteIndexChange(int noteIndex) => Dispatcher.Dispatch(
        new UpdateInstrumentConfiguration(
            Instrument,
            CompositionConfigurationState.Value.AvailableNotes[noteIndex],
            HighestPitchNote,
            MinVelocity,
            MaxVelocity,
            MidiInstrument,
            Status,
            IsUserApplied: true
        )
    );

    private void HandleHighestPitchIndexChange(int noteIndex) => Dispatcher.Dispatch(
        new UpdateInstrumentConfiguration(
            Instrument,
            LowestPitchNote,
            CompositionConfigurationState.Value.AvailableNotes[noteIndex],
            MinVelocity,
            MaxVelocity,
            MidiInstrument,
            Status,
            IsUserApplied: true
        )
    );

    private void HandleMidiInstrumentChange(GeneralMidi2Program instrument) => Dispatcher.Dispatch(
        new UpdateInstrumentConfiguration(
            Instrument,
            LowestPitchNote,
            HighestPitchNote,
            MinVelocity,
            MaxVelocity,
            instrument,
            Status,
            IsUserApplied: true
        )
    );

    private void HandleInstrumentFilterChange()
    {
        if (!MidiInstrumentFilters.Any(filter => filter.IsEnabled))
        {
            MidiInstruments = MidiInstrumentRepository.GetAllMidiInstruments().ToFrozenDictionary(
                instrument => instrument.ToSpaceSeparatedString(),
                instrument => instrument
            );

            return;
        }

        var includedMidiInstruments = MidiInstrumentFilters.Where(filter => filter.IsEnabled).Aggregate(MidiInstrumentType.None, (current, filter) => current | filter.Type);
        var midiInstruments = MidiInstrumentRepository.GetMidiInstruments(includedMidiInstruments).ToList();

        MidiInstruments = midiInstruments.ToFrozenDictionary(
            instrument => instrument.ToSpaceSeparatedString(),
            instrument => instrument
        );

        if (MidiInstruments.ContainsKey(MidiInstrument.ToSpaceSeparatedString()))
        {
            return;
        }

        Dispatcher.Dispatch(new UpdateInstrumentConfiguration(
            Instrument,
            LowestPitchNote,
            HighestPitchNote,
            MinVelocity,
            MaxVelocity,
            MidiInstruments.Values.Order().First(),
            Status,
            IsUserApplied: true
        ));
    }

    private void HandleMinVelocityChange(byte velocity) => Dispatcher.Dispatch(
        new UpdateInstrumentConfiguration(
            Instrument,
            LowestPitchNote,
            HighestPitchNote,
            new SevenBitNumber(velocity),
            MaxVelocity,
            MidiInstrument,
            Status,
            IsUserApplied: true
        )
    );

    private void HandleMaxVelocityChange(byte velocity) => Dispatcher.Dispatch(
        new UpdateInstrumentConfiguration(
            Instrument,
            LowestPitchNote,
            HighestPitchNote,
            MinVelocity,
            new SevenBitNumber(velocity),
            MidiInstrument,
            Status,
            IsUserApplied: true
        )
    );

    private async Task<IEnumerable<GeneralMidi2Program>> MidiInstrumentSearchFunc(string search, CancellationToken cancellationToken)
    {
        var midiInstruments = string.IsNullOrWhiteSpace(search)
            ? MidiInstruments.Values
            : MidiInstruments.Keys
                .Where(key => key.Contains(search, StringComparison.OrdinalIgnoreCase))
                .Select(key => MidiInstruments[key]);

        return await Task.FromResult(midiInstruments.OrderBy(instrument => instrument.ToSpaceSeparatedString(), StringComparer.OrdinalIgnoreCase));
    }

    protected virtual void Dispose(bool disposing)
    {
        if (disposing)
        {
            InstrumentConfigurationStateSubscription?.Dispose();
        }
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
}
